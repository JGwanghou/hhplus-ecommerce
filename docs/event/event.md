## 서비스 규모 확장 시 서비스 책임 및 분리에 관한 분석

### 어떻게 분리할 것 인가?
 - 주문 서비스 : `Order`(root aggregate) 기준으로 서브 도메인 및 주문에 관한 처리 
 - 상품 서비스 : `Product`(root aggregate) 기준으로 서브 도메인 및 상품에 관한 처리 
 - 유저 서비스 : `User`(root aggregate) 기준으로 서브 도메인 및 상품에 관한 처리

명확한 책임 분리로 유지보수성이 뛰어나고 단일 모듈 장애에 대해 전체 어플리케이션은 영향을 받지 않습니다.

하지만, Multiple Databases 및 트랜잭션 관리에 대한 어려움이 존재합니다.

### 어떤 어려움이 존재하는가?
 - 문제 상황 1. 하나의 트랜잭션이 너무 많은 작업 혹은 느린 조회 등을 처리하는 경우
    - SlowRead 작업으로 인해 요청 처리에 영향
    - Transaction 범위 내에서 Lock 을 사용하고 있을 경우, 해당 자원에 접근하는 다른 요청의 대기 혹은 데드락 상황을 유발
    - 긴 생명 주기의 Transaction 의 경우, 오랜 시간은 소요되나 후속 작업에 의해 전체 트랜잭션이 실패
 - 문제 상황 2. 트랜잭션 범위 내에서 DB 와 무관한 작업을 수행하고 있는 경우
    - DB 외적인 작업의 성공 유무가 전체 비즈니스로직에 영향을 끼쳐 rollback 되는 경우
      - ex) 알림톡 전송

### 어떻게 관리할 것 인가?
검증도 하고, 재고도 차감하고, 주문도 만들고, 결제도 하는 등 단일 비즈니스 로직에 과도한 책임이 주어져 있을 수 있습니다. 
이때 `Event` 기반의 패턴을 이용한 `Event 발행 및 구독`으로 코드 강결합을 분리 시킬 수 있습니다.

유저 서비스로 예를 들면, `유저서비스 본인은 포인트 차감(관심사)만 수행`해야하며 재고관리에 대한 세부사항은 알 필요가 없습니다.

### 이벤트 드리븐 아키텍쳐 (Event Driven Architecture)
 - ApplicationEventPublisher 이용한 이벤트 발행
 - Kafka 이용한 이벤트 발행

### 보상 트랜잭션
이벤트에 의해 진행된 트랜잭션이 정상적으로 수행하지 못했을 경우 아래 패턴을 적용할 수 있다.
- 2Phase Commit 패턴(2PC 패턴)
- SAGA 패턴




